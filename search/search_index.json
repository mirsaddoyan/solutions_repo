{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is a fundamental topic in mechanics that offers a clean yet rich context for understanding the application of differential equations, Newton's laws, and kinematic principles. The central goal is to investigate how the horizontal range of a projectile depends on the angle of launch. Though the setup appears straightforward, the analysis reveals intricate dependencies on initial conditions and physical parameters. Understanding projectile motion is essential in a variety of fields\u2014from sports and civil engineering to space science and military applications. By starting from first principles and layering in simulation, this project provides both theoretical insight and computational practice. 1. Theoretical Foundation: Differential Equations Assumptions: The motion is in two dimensions. Air resistance is neglected. Gravity acts uniformly downward. Launch and landing heights are equal. We begin with Newton's second law: \\(\\vec{F} = m\\vec{a} \\Rightarrow \\frac{d^2 \\vec{r}}{dt^2} = \\vec{a}\\) Decomposing motion into x (horizontal) and y (vertical) directions: Horizontal Motion: \\(\\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) t\\) Vertical Motion: \\(\\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\) Time of Flight: Set \\(y(t) = 0\\) to find when the projectile lands: \\(t = \\frac{2v_0 \\sin(\\theta)}{g}\\) Horizontal Range: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) This is the key result showing how range depends on initial velocity, gravity, and angle. 2. Simulation: Python Code and Visualizations Range vs. Angle Plot import numpy as np import matplotlib.pyplot as plt v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s^2 angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Calculate range R = (v0**2 * np.sin(2 * angles_rad)) / g # Plot range vs angle plt.figure(figsize=(10, 6)) plt.plot(angles, R, color='royalblue') plt.axvline(45, color='red', linestyle='--', label='\\u03b8 = 45\\xb0 (Max Range)') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() Visit: Colab Multiple Trajectories for Different Angles # Time vector angles_deg = [15, 30, 45, 60, 75] colors = ['blue', 'green', 'orange', 'purple', 'brown'] plt.figure(figsize=(10, 6)) for angle, color in zip(angles_deg, colors): theta = np.radians(angle) t_flight = 2 * v0 * np.sin(theta) / g t_vals = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t_vals y = v0 * np.sin(theta) * t_vals - 0.5 * g * t_vals**2 plt.plot(x, y, label=f\"{angle}\u00b0\", color=color) plt.title(\"Projectile Trajectories for Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.show() Output: Visit: Colab Animated Projectile Motion import matplotlib.animation as animation fig, ax = plt.subplots(figsize=(8, 5)) angle = np.radians(45) t_flight = 2 * v0 * np.sin(angle) / g t_vals = np.linspace(0, t_flight, 300) x_vals = v0 * np.cos(angle) * t_vals y_vals = v0 * np.sin(angle) * t_vals - 0.5 * g * t_vals**2 line, = ax.plot([], [], 'bo') ax.set_xlim(0, max(x_vals)) ax.set_ylim(0, max(y_vals)*1.1) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Vertical Height (m)') ax.set_title('Animated Projectile Motion') # Initialization function def init(): line.set_data([], []) return line, # Animation function def animate(i): line.set_data(x_vals[i], y_vals[i]) return line, ani = animation.FuncAnimation(fig, animate, frames=len(t_vals), init_func=init, interval=20, blit=True) plt.show() Visit: Colab Range vs. Angle for Different Velocities velocities = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) for v in velocities: R = (v**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, R, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Angle for Various Initial Velocities') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() Visit Colab Output: Curves rising in height as initial velocity increases, but always peaking at 45\u00b0. 3. Practical Applications Sports : Optimize kicking or throwing angles. Engineering : Design water fountains, civil projectiles, or robotic arm paths. Aerospace : Launch trajectories under different gravitational conditions. Defense : Missile and artillery trajectory planning. 4. Extensions and Real-World Models Air Resistance Introducing drag results in non-linear differential equations. For example: \\(m \\frac{d^2x}{dt^2} = -kv_x, \\quad m \\frac{d^2y}{dt^2} = -mg - kv_y\\) where \\(k\\) is the drag coefficient. This requires numerical solving methods (like Runge-Kutta) for simulation. Python Simulation with Air Resistance (Euler Method) def simulate_drag(v0, theta_deg, dt=0.01, k=0.1): theta = np.radians(theta_deg) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = 0, 0 positions_x, positions_y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) return positions_x, positions_y plt.figure(figsize=(10, 6)) for angle in [30, 45, 60]: x_vals, y_vals = simulate_drag(30, angle) plt.plot(x_vals, y_vals, label=f\"With drag, {angle}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.title(\"Projectile Motion with Air Resistance\") plt.legend() plt.grid(True) plt.show() Visit Colab Uneven Terrain and Variable Gravity Other extensions include: - Launching from/landing on slopes (geometry needed) - Varying \\(g\\) with altitude or planetary conditions Conclusion Starting from Newton's laws, we built a full mathematical model of projectile motion using differential equations. We derived the range formula and implemented visual simulations to understand how the angle of projection affects range. The model, while idealized, provides deep insight and serves as a powerful foundation for more complex analyses. With Python, we've created tools to simulate, visualize, and animate this system dynamically. Extensions include modeling drag and simulating on non-flat terrains\u2014perfect for bridging theory and real-world applications.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is a fundamental topic in mechanics that offers a clean yet rich context for understanding the application of differential equations, Newton's laws, and kinematic principles. The central goal is to investigate how the horizontal range of a projectile depends on the angle of launch. Though the setup appears straightforward, the analysis reveals intricate dependencies on initial conditions and physical parameters. Understanding projectile motion is essential in a variety of fields\u2014from sports and civil engineering to space science and military applications. By starting from first principles and layering in simulation, this project provides both theoretical insight and computational practice.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-differential-equations","text":"","title":"1. Theoretical Foundation: Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"The motion is in two dimensions. Air resistance is neglected. Gravity acts uniformly downward. Launch and landing heights are equal. We begin with Newton's second law: \\(\\vec{F} = m\\vec{a} \\Rightarrow \\frac{d^2 \\vec{r}}{dt^2} = \\vec{a}\\) Decomposing motion into x (horizontal) and y (vertical) directions:","title":"Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\(\\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) t\\)","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\(\\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2\\)","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Set \\(y(t) = 0\\) to find when the projectile lands: \\(t = \\frac{2v_0 \\sin(\\theta)}{g}\\)","title":"Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\(R = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) This is the key result showing how range depends on initial velocity, gravity, and angle.","title":"Horizontal Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-simulation-python-code-and-visualizations","text":"","title":"2. Simulation: Python Code and Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-plot","text":"import numpy as np import matplotlib.pyplot as plt v0 = 30 # initial velocity in m/s g = 9.81 # gravitational acceleration in m/s^2 angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Calculate range R = (v0**2 * np.sin(2 * angles_rad)) / g # Plot range vs angle plt.figure(figsize=(10, 6)) plt.plot(angles, R, color='royalblue') plt.axvline(45, color='red', linestyle='--', label='\\u03b8 = 45\\xb0 (Max Range)') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() Visit: Colab","title":"Range vs. Angle Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#multiple-trajectories-for-different-angles","text":"# Time vector angles_deg = [15, 30, 45, 60, 75] colors = ['blue', 'green', 'orange', 'purple', 'brown'] plt.figure(figsize=(10, 6)) for angle, color in zip(angles_deg, colors): theta = np.radians(angle) t_flight = 2 * v0 * np.sin(theta) / g t_vals = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t_vals y = v0 * np.sin(theta) * t_vals - 0.5 * g * t_vals**2 plt.plot(x, y, label=f\"{angle}\u00b0\", color=color) plt.title(\"Projectile Trajectories for Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.show()","title":"Multiple Trajectories for Different Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"Visit: Colab","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#animated-projectile-motion","text":"import matplotlib.animation as animation fig, ax = plt.subplots(figsize=(8, 5)) angle = np.radians(45) t_flight = 2 * v0 * np.sin(angle) / g t_vals = np.linspace(0, t_flight, 300) x_vals = v0 * np.cos(angle) * t_vals y_vals = v0 * np.sin(angle) * t_vals - 0.5 * g * t_vals**2 line, = ax.plot([], [], 'bo') ax.set_xlim(0, max(x_vals)) ax.set_ylim(0, max(y_vals)*1.1) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Vertical Height (m)') ax.set_title('Animated Projectile Motion') # Initialization function def init(): line.set_data([], []) return line, # Animation function def animate(i): line.set_data(x_vals[i], y_vals[i]) return line, ani = animation.FuncAnimation(fig, animate, frames=len(t_vals), init_func=init, interval=20, blit=True) plt.show()","title":"Animated Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visitcolab","text":"","title":"Visit:Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-for-different-velocities","text":"velocities = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) for v in velocities: R = (v**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, R, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Angle for Various Initial Velocities') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() Visit Colab","title":"Range vs. Angle for Different Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output_1","text":"Curves rising in height as initial velocity increases, but always peaking at 45\u00b0.","title":"Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimize kicking or throwing angles. Engineering : Design water fountains, civil projectiles, or robotic arm paths. Aerospace : Launch trajectories under different gravitational conditions. Defense : Missile and artillery trajectory planning.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-extensions-and-real-world-models","text":"","title":"4. Extensions and Real-World Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#air-resistance","text":"Introducing drag results in non-linear differential equations. For example: \\(m \\frac{d^2x}{dt^2} = -kv_x, \\quad m \\frac{d^2y}{dt^2} = -mg - kv_y\\) where \\(k\\) is the drag coefficient. This requires numerical solving methods (like Runge-Kutta) for simulation.","title":"Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation-with-air-resistance-euler-method","text":"def simulate_drag(v0, theta_deg, dt=0.01, k=0.1): theta = np.radians(theta_deg) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = 0, 0 positions_x, positions_y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) return positions_x, positions_y plt.figure(figsize=(10, 6)) for angle in [30, 45, 60]: x_vals, y_vals = simulate_drag(30, angle) plt.plot(x_vals, y_vals, label=f\"With drag, {angle}\u00b0\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.title(\"Projectile Motion with Air Resistance\") plt.legend() plt.grid(True) plt.show() Visit Colab","title":"Python Simulation with Air Resistance (Euler Method)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain-and-variable-gravity","text":"Other extensions include: - Launching from/landing on slopes (geometry needed) - Varying \\(g\\) with altitude or planetary conditions","title":"Uneven Terrain and Variable Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Starting from Newton's laws, we built a full mathematical model of projectile motion using differential equations. We derived the range formula and implemented visual simulations to understand how the angle of projection affects range. The model, while idealized, provides deep insight and serves as a powerful foundation for more complex analyses. With Python, we've created tools to simulate, visualize, and animate this system dynamically. Extensions include modeling drag and simulating on non-flat terrains\u2014perfect for bridging theory and real-world applications.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The pendulum is a powerful model in physics. From simple harmonic motion to chaos, it demonstrates how small changes \u2014 damping and forcing \u2014 result in complex behavior. This project investigates: Simple Pendulum Damped Pendulum Forced Damped Pendulum 1. Differential Equations Simple Pendulum \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = 0\\] For small angles: \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\theta = 0, \\quad \\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damped Pendulum \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\] Forced Pendulum \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] Where: \\(\\theta(t)\\) : angular displacement (in radians) \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) : natural frequency of the pendulum \\(A\\) : amplitude of the external driving force (torque per unit mass and length) \\(\\omega\\) : angular frequency of the driving force \\(t\\) : time \\(g\\) : gravitational acceleration \\(L\\) : length of the pendulum Forced Damped Pendulum \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] 2. Visualizing the Simple Pendulum (Small Angle Approximation) import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 t = np.linspace(0, 10, 1000) theta = theta0 * np.cos(omega0 * t) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Simple Pendulum (Small Angle Approximation)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 3. Visualizing the Damped Pendulum # Damped system using RK4 import numpy as np import matplotlib.pyplot as plt dt = 0.01 t = np.arange(0, 20, dt) b = 0.3 # damping theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 # Define omega0 here omega0 = 1.0 # You can change this value to the desired natural frequency def rk4_damped(theta, omega, t, dt, b, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * theta]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_damped(theta[i-1], omega[i-1], t[i-1], dt, b, omega0) plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 4. Visualizing the Forced Pendulum import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 b = 0.0 # No damping A = 1.2 # Forcing amplitude omega_d = 2/3 # Driving frequency dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) # RK4 integration for the forced pendulum def rk4_step(theta, omega, t, dt): def f(t, y): theta, omega = y dtheta = omega domega = -omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 # Simulation theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = theta0 omega[0] = omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt) # Plotting fig, axs = plt.subplots(1, 2, figsize=(12, 4)) # Time Series axs[0].plot(t, theta, color='darkorange') axs[0].set_title(\"Forced Pendulum (No Damping) - Time Series\") axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"Angle \u03b8 (rad)\") axs[0].grid(True) # Phase Portrait axs[1].plot(theta, omega, color='orangered') axs[1].set_title(\"Forced Pendulum (No Damping) - Phase Portrait\") axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"\u03c9 (rad/s)\") axs[1].grid(True) plt.tight_layout() plt.show() Visit: Colab 5. Visualizing the Forced Damped Pendulum # Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt # Parameters omega0 = 2 dt = 0.01 t = np.arange(0, 10, dt) A = 1.2 omega_d = 2/3 b = 0.5 theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 def rk4_forced(theta, omega, t, dt, b, A, omega_d, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t)]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_forced(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, omega0) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab 6. Animation of the Forced Damped Pendulum import matplotlib.animation as animation from IPython.display import HTML import numpy as np # This was missing # Assuming L represents the length of the pendulum, set it to a reasonable value L = 1 # You can adjust this value as needed x_vals = L * np.sin(theta) y_vals = -L * np.cos(theta) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.grid() line, = ax.plot([], [], 'o-', lw=2) trail, = ax.plot([], [], '-', lw=0.5) xdata, ydata = [], [] def init(): line.set_data([], []) trail.set_data([], []) return line, trail def animate(i): x, y = x_vals[i], y_vals[i] xdata.append(x) ydata.append(y) if len(xdata) > 100: xdata.pop(0) ydata.pop(0) line.set_data([0, x], [0, y]) trail.set_data(xdata, ydata) return line, trail ani = animation.FuncAnimation(fig, animate, frames=range(0, len(x_vals), 5), init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_jshtml()) Visit: Colab import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 dt = 0.01 t_max = 20 t = np.arange(0, t_max, dt) # Unified RK4 method def rk4_step(theta, omega, t, dt, b=0, A=0, omega_d=0, use_sin=True): def f(t, y): theta, omega = y dtheta = omega if use_sin: domega = -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) else: domega = -b * omega - omega0**2 * theta + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 def simulate(b=0, A=0, omega_d=0, use_sin=True): theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0], omega[0] = theta0, omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, use_sin) return theta, omega # Simulate all three theta1, omega1 = simulate(b=0, A=0, use_sin=False) # Simple theta2, omega2 = simulate(b=0.2, A=0, use_sin=False) # Damped theta3, omega3 = simulate(b=0.5, A=1.2, omega_d=2/3, use_sin=True) # Forced # Plot layout fig, axs = plt.subplots(3, 2, figsize=(12, 10)) titles = [\"1) Simple Pendulum\", \"2) Damped Pendulum\", \"3) Forced Pendulum\"] colors = ['red', 'blue', 'teal'] # Time Series axs[0, 0].plot(t, theta1, color=colors[0]) axs[1, 0].plot(t, theta2, color=colors[1]) axs[2, 0].plot(t, theta3, color=colors[2]) for i in range(3): axs[i, 0].set_title(\"Time Series\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"\u03b8 (rad)\") axs[i, 0].grid(True) axs[i, 0].annotate(titles[i], xy=(0.95, 0.85), xycoords='axes fraction', ha='right', fontsize=11, color=colors[i], weight='bold') # Phase Portraits axs[0, 1].plot(theta1, omega1, color=colors[0]) axs[1, 1].plot(theta2, omega2, color=colors[1]) axs[2, 1].plot(theta3, omega3, color=colors[2]) for i in range(3): axs[i, 1].set_title(\"Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() Visit: Colab 7. Extensions and Advanced Explorations Phase Portraits & Poincar\u00e9 Sections : Reveal geometry of motion and transitions to chaos. Bifurcation Diagrams : Vary forcing amplitude \\(A\\) or frequency \\(\\omega\\) and plot long-term values. Energy Analysis : Study how energy is gained/lost under forcing and damping. Lyapunov Exponents : Quantify sensitivity to initial conditions (chaos). Double Pendulum : A 2-link pendulum introduces deeper chaos with no external force. Planetary Gravity : Modify \\(g\\) to simulate behavior on Mars, Moon, etc. 8. Conclusion This project comprehensively examined pendulum dynamics in three stages: Variant Damping Forcing Behavior Simple Pendulum \u2718 \u2718 Periodic Damped Pendulum \u2714 \u2718 Decaying oscillations Forced Damped \u2714 \u2714 Periodic / Quasiperiodic / Chaotic We: - Derived differential equations - Simulated each case using Runge-Kutta - Visualized the systems with graphs and animations - Proposed extensions into bifurcations, chaos, and energy studies","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The pendulum is a powerful model in physics. From simple harmonic motion to chaos, it demonstrates how small changes \u2014 damping and forcing \u2014 result in complex behavior. This project investigates: Simple Pendulum Damped Pendulum Forced Damped Pendulum","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-differential-equations","text":"","title":"1. Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simple-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = 0\\] For small angles: \\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\theta = 0, \\quad \\omega_0 = \\sqrt{\\frac{g}{L}}\\]","title":"Simple Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0\\]","title":"Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\] Where: \\(\\theta(t)\\) : angular displacement (in radians) \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) : natural frequency of the pendulum \\(A\\) : amplitude of the external driving force (torque per unit mass and length) \\(\\omega\\) : angular frequency of the driving force \\(t\\) : time \\(g\\) : gravitational acceleration \\(L\\) : length of the pendulum","title":"Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"\\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t)\\]","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-visualizing-the-simple-pendulum-small-angle-approximation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 t = np.linspace(0, 10, 1000) theta = theta0 * np.cos(omega0 * t) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Simple Pendulum (Small Angle Approximation)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"2. Visualizing the Simple Pendulum (Small Angle Approximation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-visualizing-the-damped-pendulum","text":"# Damped system using RK4 import numpy as np import matplotlib.pyplot as plt dt = 0.01 t = np.arange(0, 20, dt) b = 0.3 # damping theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 # Define omega0 here omega0 = 1.0 # You can change this value to the desired natural frequency def rk4_damped(theta, omega, t, dt, b, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * theta]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_damped(theta[i-1], omega[i-1], t[i-1], dt, b, omega0) plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"3. Visualizing the Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-visualizing-the-forced-pendulum","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 b = 0.0 # No damping A = 1.2 # Forcing amplitude omega_d = 2/3 # Driving frequency dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) # RK4 integration for the forced pendulum def rk4_step(theta, omega, t, dt): def f(t, y): theta, omega = y dtheta = omega domega = -omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 # Simulation theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = theta0 omega[0] = omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt) # Plotting fig, axs = plt.subplots(1, 2, figsize=(12, 4)) # Time Series axs[0].plot(t, theta, color='darkorange') axs[0].set_title(\"Forced Pendulum (No Damping) - Time Series\") axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"Angle \u03b8 (rad)\") axs[0].grid(True) # Phase Portrait axs[1].plot(theta, omega, color='orangered') axs[1].set_title(\"Forced Pendulum (No Damping) - Phase Portrait\") axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"\u03c9 (rad/s)\") axs[1].grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"4. Visualizing the Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualizing-the-forced-damped-pendulum","text":"# Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt # Parameters omega0 = 2 dt = 0.01 t = np.arange(0, 10, dt) A = 1.2 omega_d = 2/3 b = 0.5 theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0] = 0.5 def rk4_forced(theta, omega, t, dt, b, A, omega_d, omega0): def f(t, y): theta, omega = y return np.array([omega, -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t)]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 for i in range(1, len(t)): theta[i], omega[i] = rk4_forced(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, omega0) # Plot plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Visit: Colab","title":"5. Visualizing the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-animation-of-the-forced-damped-pendulum","text":"import matplotlib.animation as animation from IPython.display import HTML import numpy as np # This was missing # Assuming L represents the length of the pendulum, set it to a reasonable value L = 1 # You can adjust this value as needed x_vals = L * np.sin(theta) y_vals = -L * np.cos(theta) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.grid() line, = ax.plot([], [], 'o-', lw=2) trail, = ax.plot([], [], '-', lw=0.5) xdata, ydata = [], [] def init(): line.set_data([], []) trail.set_data([], []) return line, trail def animate(i): x, y = x_vals[i], y_vals[i] xdata.append(x) ydata.append(y) if len(xdata) > 100: xdata.pop(0) ydata.pop(0) line.set_data([0, x], [0, y]) trail.set_data(xdata, ydata) return line, trail ani = animation.FuncAnimation(fig, animate, frames=range(0, len(x_vals), 5), init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_jshtml())","title":"6. Animation of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visit-colab","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 dt = 0.01 t_max = 20 t = np.arange(0, t_max, dt) # Unified RK4 method def rk4_step(theta, omega, t, dt, b=0, A=0, omega_d=0, use_sin=True): def f(t, y): theta, omega = y dtheta = omega if use_sin: domega = -b * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) else: domega = -b * omega - omega0**2 * theta + A * np.cos(omega_d * t) return np.array([dtheta, domega]) y = np.array([theta, omega]) k1 = f(t, y) k2 = f(t + dt/2, y + dt*k1/2) k3 = f(t + dt/2, y + dt*k2/2) k4 = f(t + dt, y + dt*k3) return y + dt * (k1 + 2*k2 + 2*k3 + k4)/6 def simulate(b=0, A=0, omega_d=0, use_sin=True): theta = np.zeros_like(t) omega = np.zeros_like(t) theta[0], omega[0] = theta0, omega_init for i in range(1, len(t)): theta[i], omega[i] = rk4_step(theta[i-1], omega[i-1], t[i-1], dt, b, A, omega_d, use_sin) return theta, omega # Simulate all three theta1, omega1 = simulate(b=0, A=0, use_sin=False) # Simple theta2, omega2 = simulate(b=0.2, A=0, use_sin=False) # Damped theta3, omega3 = simulate(b=0.5, A=1.2, omega_d=2/3, use_sin=True) # Forced # Plot layout fig, axs = plt.subplots(3, 2, figsize=(12, 10)) titles = [\"1) Simple Pendulum\", \"2) Damped Pendulum\", \"3) Forced Pendulum\"] colors = ['red', 'blue', 'teal'] # Time Series axs[0, 0].plot(t, theta1, color=colors[0]) axs[1, 0].plot(t, theta2, color=colors[1]) axs[2, 0].plot(t, theta3, color=colors[2]) for i in range(3): axs[i, 0].set_title(\"Time Series\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"\u03b8 (rad)\") axs[i, 0].grid(True) axs[i, 0].annotate(titles[i], xy=(0.95, 0.85), xycoords='axes fraction', ha='right', fontsize=11, color=colors[i], weight='bold') # Phase Portraits axs[0, 1].plot(theta1, omega1, color=colors[0]) axs[1, 1].plot(theta2, omega2, color=colors[1]) axs[2, 1].plot(theta3, omega3, color=colors[2]) for i in range(3): axs[i, 1].set_title(\"Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() Visit: Colab","title":"Visit: Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-extensions-and-advanced-explorations","text":"Phase Portraits & Poincar\u00e9 Sections : Reveal geometry of motion and transitions to chaos. Bifurcation Diagrams : Vary forcing amplitude \\(A\\) or frequency \\(\\omega\\) and plot long-term values. Energy Analysis : Study how energy is gained/lost under forcing and damping. Lyapunov Exponents : Quantify sensitivity to initial conditions (chaos). Double Pendulum : A 2-link pendulum introduces deeper chaos with no external force. Planetary Gravity : Modify \\(g\\) to simulate behavior on Mars, Moon, etc.","title":"7. Extensions and Advanced Explorations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-conclusion","text":"This project comprehensively examined pendulum dynamics in three stages: Variant Damping Forcing Behavior Simple Pendulum \u2718 \u2718 Periodic Damped Pendulum \u2714 \u2718 Decaying oscillations Forced Damped \u2714 \u2714 Periodic / Quasiperiodic / Chaotic We: - Derived differential equations - Simulated each case using Runge-Kutta - Visualized the systems with graphs and animations - Proposed extensions into bifurcations, chaos, and energy studies","title":"8. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The elegant relationship between the square of the orbital period (T) and the cube of the orbital radius (r) for circular orbits, known as Kepler\u2019s Third Law , reveals deep insights into gravitational interactions. This project aims to derive this law starting from Newtonian mechanics and differential equations, explore its real-world implications, and validate it through simulations and animations. Kepler\u2019s Third Law reveals a fundamental relationship in orbital mechanics: \\[T^2 \\propto r^3\\] This law connects the period of revolution \\(T\\) of a planet (or satellite) with the radius \\(r\\) of its circular orbit. It's a powerful tool used in celestial mechanics, satellite design, and calculating masses of celestial bodies. Theoretical Derivation using Newtonian Mechanics Step 1: Gravitational Force Newton\u2019s Law of Gravitation \\[F_g = \\frac{G M m}{r^2}\\] Step 2: Centripetal Force for Circular Orbits \\[F_c = \\frac{m v^2}{r}\\] Step 3: Equating Forces \\[\\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\] Step 4: Express Orbital Period \\[T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2}\\] Substitute \\(v^2\\) : \\[T^2 = \\frac{4\\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4\\pi^2 r^3}{G M}\\] Final Form: \\[T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\Rightarrow T^2 \\propto r^3\\] Theoretical Analysis via Differential Equations Newton\u2019s Law of Universal Gravitation Gravitational force between two bodies of mass \\(M\\) (e.g., Earth) and \\(m\\) (e.g., satellite) is: \\[F = \\frac{G M m}{r^2}\\] Circular Motion Requirement For an object to stay in circular orbit, this gravitational force must equal the centripetal force: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\] Derivation Using Differential Equations The radial acceleration for a mass \\(m\\) in circular motion is: \\[\\vec{a} = \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^2} \\hat{r}\\] If the motion is constrained to a circular orbit, the position vector is: \\[\\vec{r}(t) = r (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j})\\] Differentiating twice gives: \\[\\frac{d^2 \\vec{r}}{dt^2} = -r \\omega^2 (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j}) = -\\omega^2 \\vec{r}\\] From Newton\u2019s second law: \\[m \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M m}{r^2} \\hat{r} \\Rightarrow -m \\omega^2 \\vec{r} = -\\frac{G M m}{r^2} \\hat{r}\\] Solving: \\[\\omega^2 = \\frac{G M}{r^3} \\Rightarrow T^2 = \\left( \\frac{2\\pi}{\\omega} \\right)^2 = \\frac{4\\pi^2 r^3}{G M}\\] This is Kepler\u2019s Third Law for circular orbits. Real-World Examples Moon's Orbit Around Earth Radius: \\(r \\approx 3.84 \\times 10^8\\) m Period: \\(T \\approx 27.3\\) days Verify Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) Planets in the Solar System Planet Orbital Radius (AU) Period (years) Mercury 0.39 0.24 Earth 1.00 1.00 Jupiter 5.20 11.86 \\[\\frac{T^2}{r^3} \\approx \\text{constant}\\] import matplotlib.pyplot as plt import numpy as np # Sample data (replace with your actual data) radius = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.54]) # AU period = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Calculate T^2 and R^3 T_squared = period**2 R_cubed = radius**3 # Create the plot plt.figure(figsize=(8, 6)) plt.scatter(R_cubed, T_squared, label='Data Points') # Create the scatter plot # Add a best fit line (linear regression) coefficients = np.polyfit(R_cubed, T_squared, 1) polynomial = np.poly1d(coefficients) R_cubed_fit = np.linspace(min(R_cubed), max(R_cubed), 100) plt.plot(R_cubed_fit, polynomial(R_cubed_fit), color='red', label='Best Fit Line') # Add labels and title plt.xlabel(r'$R^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (years$^2$)') plt.title('Orbital Period vs. Radius (Kepler\\'s Third Law)') plt.grid(True) # Add grid for better readability plt.legend() # Calculate and print the slope slope = coefficients[0] print(f\"Slope of the best-fit line: {slope:.2f}\") # Add text annotation showing the slope on the plot. plt.annotate(f\"Slope: {slope:.2f}\", xy=(0.65 * max(R_cubed), 0.85 * max(T_squared)), fontsize=12) # Show the plot plt.show() Visit: Colab Verifying Kepler\u2019s Law !pip install ace_tools # Install the required 'ace_tools' module import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns # Orbital data for planets (radius in AU, period in years) planets = { \"Mercury\": {\"r_AU\": 0.39, \"T_years\": 0.240846}, \"Venus\": {\"r_AU\": 0.723, \"T_years\": 0.615}, \"Earth\": {\"r_AU\": 1.000, \"T_years\": 1.000}, \"Mars\": {\"r_AU\": 1.524, \"T_years\": 1.881} } # Convert to arrays names = list(planets.keys()) r_AU = np.array([planets[p][\"r_AU\"] for p in names]) T_years = np.array([planets[p][\"T_years\"] for p in names]) # Calculate T^2 and r^3 T_squared = T_years**2 r_cubed = r_AU**3 # Create a DataFrame for visualization df = pd.DataFrame({ \"Planet\": names, \"r (AU)\": r_AU, \"T (years)\": T_years, \"r^3 (AU^3)\": r_cubed, \"T^2 (years^2)\": T_squared }) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 6)) sns.scatterplot(x=r_cubed, y=T_squared, hue=names, s=100) plt.plot(r_cubed, T_squared, 'k--', alpha=0.6) # Line for visual confirmation plt.xlabel(\"r\u00b3 (AU\u00b3)\") plt.ylabel(\"T\u00b2 (years\u00b2)\") plt.title(\"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend(title=\"Planet\") plt.tight_layout() plt.show() import ace_tools as tools; tools.display_dataframe_to_user(name=\"Planetary Orbital Data\", dataframe=df) Visit: Colab Planetary Orbital Data (AU & Years) Planet Orbital Radius \\( r \\) (AU) Orbital Period \\( T \\) (years) \\( r^3 \\) (AU\u00b3) \\( T^2 \\) (years\u00b2) Mercury 0.390 0.240846 0.059319 0.058007 Venus 0.723 0.615 0.377933 0.378225 Earth 1.000 1.000 1.000000 1.000000 Mars 1.524 1.881 3.539606 3.538161 Animation of a Circular Orbit import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) r = 3.84e8 # Radius of the orbit (Moon-Earth distance, m) omega = np.sqrt(G * M / r**3) # Angular velocity (rad/s) # Time settings T = 2 * np.pi / omega # Orbital period (s) t_vals = np.linspace(0, T, 500) # Time points # Orbital coordinates x_vals = r * np.cos(omega * t_vals) y_vals = r * np.sin(omega * t_vals) # Plot setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.set_title('Circular Orbit') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') # Static Earth ax.plot(0, 0, 'yo', markersize=12, label='Earth') # Satellite dot and path satellite, = ax.plot([], [], 'ro', label='Satellite') path, = ax.plot([], [], 'r--', alpha=0.5) def init(): satellite.set_data([], []) path.set_data([], []) return satellite, path def update(frame): # Ensure x and y are lists or 1-dimensional arrays x = [x_vals[frame]] # or x = np.array([x_vals[frame]]) y = [y_vals[frame]] # or y = np.array([y_vals[frame]]) satellite.set_data(x, y) path.set_data(x_vals[:frame+1], y_vals[:frame+1]) return satellite, path ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True, interval=20) # Display in Jupyter/Colab HTML(ani.to_jshtml()) Visit: Colab Extensions to Elliptical Orbits Kepler\u2019s Third Law generalizes to elliptical orbits: \\[T^2 \\propto a^3\\] Where \\(a\\) is the semi-major axis . This law still holds but requires integration over elliptical motion, using: Vis-viva equation: \\(v^2 = G M \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\\) Orbital energy methods Numerical integration for eccentric orbits Astronomical Implications Calculate planetary masses Estimate satellite altitudes Study exoplanet orbits Design satellite constellations (e.g., Starlink) Measure black hole masses via stellar motion Aspect Description Law \\(T^2 \\propto r^3\\) for circular orbits Derived From Newton\u2019s Law + differential equations Verification Simulations, plots of \\(T^2\\) vs \\(r^3\\) Used For Planetary systems, satellites, exoplanets Animation Visualized stable orbit with Python Kepler\u2019s Law Applied to the Solar System Planets: Mercury, Venus, Earth, Mars Planet Orbital Radius (10\u2078 km) Period (days) Mercury 57.9 87.97 Venus 108.2 224.70 Earth 149.6 365.25 Mars 227.9 687.00 Calculating Mass of Earth (Using the Moon) \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) G = 6.67430e-11 r_earth_moon = 3.844e8 T_moon = 27.32 * 86400 M_earth = 4 * np.pi**2 * r_earth_moon**3 / (G * T_moon**2) print(f\"Mass of Earth \u2248 {M_earth:.2e} kg\") Output: \\(5.97 \\times 10^{24} \\, \\text{kg}\\) (correct) Calculating Mass of the Sun (Using Earth's Orbit) \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) \\(T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) r_earth_sun = 1.496e11 T_earth = 365.25 * 86400 M_sun = 4 * np.pi**2 * r_earth_sun**3 / (G * T_earth**2) print(f\"Mass of Sun \u2248 {M_sun:.2e} kg\") Output: \\(1.99 \\times 10^{30} \\, \\text{kg}\\) (correct) Orbit Animation from matplotlib.animation import FuncAnimation from IPython.display import HTML # Time setup t_vals = np.linspace(0, 2 * np.pi, 500) x_vals = r_earth_sun * np.cos(t_vals) y_vals = r_earth_sun * np.sin(t_vals) fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_ylim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') earth, = ax.plot([], [], 'ro') sun = ax.plot(0, 0, 'yo', markersize=12) def init(): earth.set_data([], []) return earth, def update(i): earth.set_data(x_vals[i], y_vals[i]) return earth, ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True) HTML(ani.to_jshtml()) Visit: Colab Concept Value Kepler's Law \\(T^2 \\propto r^3\\) Derived from Newton's Gravity + Centripetal Motion T\u00b2 vs r\u00b3 Plot Straight line confirmed Mass of Earth \\(\\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) Mass of Sun \\(\\approx 1.99 \\times 10^{30} \\, \\text{kg}\\) Planets Used Mercury, Venus, Earth, Mars Python All steps simulated and visualized","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The elegant relationship between the square of the orbital period (T) and the cube of the orbital radius (r) for circular orbits, known as Kepler\u2019s Third Law , reveals deep insights into gravitational interactions. This project aims to derive this law starting from Newtonian mechanics and differential equations, explore its real-world implications, and validate it through simulations and animations. Kepler\u2019s Third Law reveals a fundamental relationship in orbital mechanics: \\[T^2 \\propto r^3\\] This law connects the period of revolution \\(T\\) of a planet (or satellite) with the radius \\(r\\) of its circular orbit. It's a powerful tool used in celestial mechanics, satellite design, and calculating masses of celestial bodies.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-derivation-using-newtonian-mechanics","text":"","title":"Theoretical Derivation using Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-gravitational-force","text":"Newton\u2019s Law of Gravitation \\[F_g = \\frac{G M m}{r^2}\\]","title":"Step 1: Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-centripetal-force-for-circular-orbits","text":"\\[F_c = \\frac{m v^2}{r}\\]","title":"Step 2: Centripetal Force for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-equating-forces","text":"\\[\\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\]","title":"Step 3: Equating Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-express-orbital-period","text":"\\[T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2}\\] Substitute \\(v^2\\) : \\[T^2 = \\frac{4\\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4\\pi^2 r^3}{G M}\\] Final Form: \\[T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\Rightarrow T^2 \\propto r^3\\]","title":"Step 4: Express Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-analysis-via-differential-equations","text":"","title":"Theoretical Analysis via Differential Equations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-universal-gravitation","text":"Gravitational force between two bodies of mass \\(M\\) (e.g., Earth) and \\(m\\) (e.g., satellite) is: \\[F = \\frac{G M m}{r^2}\\]","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-motion-requirement","text":"For an object to stay in circular orbit, this gravitational force must equal the centripetal force: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r}\\]","title":"Circular Motion Requirement"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-using-differential-equations","text":"The radial acceleration for a mass \\(m\\) in circular motion is: \\[\\vec{a} = \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^2} \\hat{r}\\] If the motion is constrained to a circular orbit, the position vector is: \\[\\vec{r}(t) = r (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j})\\] Differentiating twice gives: \\[\\frac{d^2 \\vec{r}}{dt^2} = -r \\omega^2 (\\cos(\\omega t)\\hat{i} + \\sin(\\omega t)\\hat{j}) = -\\omega^2 \\vec{r}\\] From Newton\u2019s second law: \\[m \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M m}{r^2} \\hat{r} \\Rightarrow -m \\omega^2 \\vec{r} = -\\frac{G M m}{r^2} \\hat{r}\\] Solving: \\[\\omega^2 = \\frac{G M}{r^3} \\Rightarrow T^2 = \\left( \\frac{2\\pi}{\\omega} \\right)^2 = \\frac{4\\pi^2 r^3}{G M}\\] This is Kepler\u2019s Third Law for circular orbits.","title":"Derivation Using Differential Equations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth","text":"Radius: \\(r \\approx 3.84 \\times 10^8\\) m Period: \\(T \\approx 27.3\\) days Verify Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\)","title":"Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planet Orbital Radius (AU) Period (years) Mercury 0.39 0.24 Earth 1.00 1.00 Jupiter 5.20 11.86 \\[\\frac{T^2}{r^3} \\approx \\text{constant}\\] import matplotlib.pyplot as plt import numpy as np # Sample data (replace with your actual data) radius = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.54]) # AU period = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Calculate T^2 and R^3 T_squared = period**2 R_cubed = radius**3 # Create the plot plt.figure(figsize=(8, 6)) plt.scatter(R_cubed, T_squared, label='Data Points') # Create the scatter plot # Add a best fit line (linear regression) coefficients = np.polyfit(R_cubed, T_squared, 1) polynomial = np.poly1d(coefficients) R_cubed_fit = np.linspace(min(R_cubed), max(R_cubed), 100) plt.plot(R_cubed_fit, polynomial(R_cubed_fit), color='red', label='Best Fit Line') # Add labels and title plt.xlabel(r'$R^3$ (AU$^3$)') plt.ylabel(r'$T^2$ (years$^2$)') plt.title('Orbital Period vs. Radius (Kepler\\'s Third Law)') plt.grid(True) # Add grid for better readability plt.legend() # Calculate and print the slope slope = coefficients[0] print(f\"Slope of the best-fit line: {slope:.2f}\") # Add text annotation showing the slope on the plot. plt.annotate(f\"Slope: {slope:.2f}\", xy=(0.65 * max(R_cubed), 0.85 * max(T_squared)), fontsize=12) # Show the plot plt.show() Visit: Colab","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verifying-keplers-law","text":"!pip install ace_tools # Install the required 'ace_tools' module import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns # Orbital data for planets (radius in AU, period in years) planets = { \"Mercury\": {\"r_AU\": 0.39, \"T_years\": 0.240846}, \"Venus\": {\"r_AU\": 0.723, \"T_years\": 0.615}, \"Earth\": {\"r_AU\": 1.000, \"T_years\": 1.000}, \"Mars\": {\"r_AU\": 1.524, \"T_years\": 1.881} } # Convert to arrays names = list(planets.keys()) r_AU = np.array([planets[p][\"r_AU\"] for p in names]) T_years = np.array([planets[p][\"T_years\"] for p in names]) # Calculate T^2 and r^3 T_squared = T_years**2 r_cubed = r_AU**3 # Create a DataFrame for visualization df = pd.DataFrame({ \"Planet\": names, \"r (AU)\": r_AU, \"T (years)\": T_years, \"r^3 (AU^3)\": r_cubed, \"T^2 (years^2)\": T_squared }) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 6)) sns.scatterplot(x=r_cubed, y=T_squared, hue=names, s=100) plt.plot(r_cubed, T_squared, 'k--', alpha=0.6) # Line for visual confirmation plt.xlabel(\"r\u00b3 (AU\u00b3)\") plt.ylabel(\"T\u00b2 (years\u00b2)\") plt.title(\"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend(title=\"Planet\") plt.tight_layout() plt.show() import ace_tools as tools; tools.display_dataframe_to_user(name=\"Planetary Orbital Data\", dataframe=df) Visit: Colab","title":"Verifying Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbital-data-au-years","text":"Planet Orbital Radius \\( r \\) (AU) Orbital Period \\( T \\) (years) \\( r^3 \\) (AU\u00b3) \\( T^2 \\) (years\u00b2) Mercury 0.390 0.240846 0.059319 0.058007 Venus 0.723 0.615 0.377933 0.378225 Earth 1.000 1.000 1.000000 1.000000 Mars 1.524 1.881 3.539606 3.538161","title":"Planetary Orbital Data (AU &amp; Years)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#animation-of-a-circular-orbit","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) r = 3.84e8 # Radius of the orbit (Moon-Earth distance, m) omega = np.sqrt(G * M / r**3) # Angular velocity (rad/s) # Time settings T = 2 * np.pi / omega # Orbital period (s) t_vals = np.linspace(0, T, 500) # Time points # Orbital coordinates x_vals = r * np.cos(omega * t_vals) y_vals = r * np.sin(omega * t_vals) # Plot setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.set_title('Circular Orbit') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') # Static Earth ax.plot(0, 0, 'yo', markersize=12, label='Earth') # Satellite dot and path satellite, = ax.plot([], [], 'ro', label='Satellite') path, = ax.plot([], [], 'r--', alpha=0.5) def init(): satellite.set_data([], []) path.set_data([], []) return satellite, path def update(frame): # Ensure x and y are lists or 1-dimensional arrays x = [x_vals[frame]] # or x = np.array([x_vals[frame]]) y = [y_vals[frame]] # or y = np.array([y_vals[frame]]) satellite.set_data(x, y) path.set_data(x_vals[:frame+1], y_vals[:frame+1]) return satellite, path ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True, interval=20) # Display in Jupyter/Colab HTML(ani.to_jshtml())","title":"Animation of a Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visitcolab","text":"","title":"Visit:Colab"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions-to-elliptical-orbits","text":"Kepler\u2019s Third Law generalizes to elliptical orbits: \\[T^2 \\propto a^3\\] Where \\(a\\) is the semi-major axis . This law still holds but requires integration over elliptical motion, using: Vis-viva equation: \\(v^2 = G M \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\\) Orbital energy methods Numerical integration for eccentric orbits","title":"Extensions to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-implications","text":"Calculate planetary masses Estimate satellite altitudes Study exoplanet orbits Design satellite constellations (e.g., Starlink) Measure black hole masses via stellar motion Aspect Description Law \\(T^2 \\propto r^3\\) for circular orbits Derived From Newton\u2019s Law + differential equations Verification Simulations, plots of \\(T^2\\) vs \\(r^3\\) Used For Planetary systems, satellites, exoplanets Animation Visualized stable orbit with Python","title":"Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-law-applied-to-the-solar-system","text":"","title":"Kepler\u2019s Law Applied to the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-mercury-venus-earth-mars","text":"Planet Orbital Radius (10\u2078 km) Period (days) Mercury 57.9 87.97 Venus 108.2 224.70 Earth 149.6 365.25 Mars 227.9 687.00","title":"Planets: Mercury, Venus, Earth, Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-mass-of-earth-using-the-moon","text":"\\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) G = 6.67430e-11 r_earth_moon = 3.844e8 T_moon = 27.32 * 86400 M_earth = 4 * np.pi**2 * r_earth_moon**3 / (G * T_moon**2) print(f\"Mass of Earth \u2248 {M_earth:.2e} kg\") Output: \\(5.97 \\times 10^{24} \\, \\text{kg}\\) (correct)","title":"Calculating Mass of Earth (Using the Moon)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-mass-of-the-sun-using-earths-orbit","text":"\\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) \\(T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) \\(M = \\frac{4 \\pi^2 r^3}{G T^2}\\) r_earth_sun = 1.496e11 T_earth = 365.25 * 86400 M_sun = 4 * np.pi**2 * r_earth_sun**3 / (G * T_earth**2) print(f\"Mass of Sun \u2248 {M_sun:.2e} kg\") Output: \\(1.99 \\times 10^{30} \\, \\text{kg}\\) (correct)","title":"Calculating Mass of the Sun (Using Earth's Orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbit-animation","text":"from matplotlib.animation import FuncAnimation from IPython.display import HTML # Time setup t_vals = np.linspace(0, 2 * np.pi, 500) x_vals = r_earth_sun * np.cos(t_vals) y_vals = r_earth_sun * np.sin(t_vals) fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_ylim(-1.2*r_earth_sun, 1.2*r_earth_sun) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') earth, = ax.plot([], [], 'ro') sun = ax.plot(0, 0, 'yo', markersize=12) def init(): earth.set_data([], []) return earth, def update(i): earth.set_data(x_vals[i], y_vals[i]) return earth, ani = FuncAnimation(fig, update, frames=len(t_vals), init_func=init, blit=True) HTML(ani.to_jshtml()) Visit: Colab Concept Value Kepler's Law \\(T^2 \\propto r^3\\) Derived from Newton's Gravity + Centripetal Motion T\u00b2 vs r\u00b3 Plot Straight line confirmed Mass of Earth \\(\\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) Mass of Sun \\(\\approx 1.99 \\times 10^{30} \\, \\text{kg}\\) Planets Used Mercury, Venus, Earth, Mars Python All steps simulated and visualized","title":"Orbit Animation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction The ability of an object to leave the gravitational influence of a celestial body is a fundamental concept in space exploration. Understanding how fast a spacecraft or any object must travel to achieve a stable orbit, escape a planet, or even leave a star system entirely is crucial for designing space missions, launching satellites, and interplanetary travel. The escape velocity is the minimum speed an object must have to completely overcome a planet\u2019s gravitational pull without further propulsion. More generally, the cosmic velocities define different velocity thresholds required for various stages of motion in space: 1. The first cosmic velocity (orbital velocity) allows an object to maintain a stable circular orbit around a planet. 2. The second cosmic velocity (escape velocity) is the minimum velocity needed to leave the planet\u2019s gravitational influence. 3. The third cosmic velocity (interplanetary velocity) is the speed required to escape a star\u2019s gravitational field from a planet\u2019s orbit. This report aims to: 1. Define and derive the equations for the first, second, and third cosmic velocities. 2. Analyze the factors affecting these velocities, such as planetary mass and radius. 3. Compute and visualize these velocities for different celestial bodies, including Earth, Mars, and Jupiter. 4. Explore their significance in space exploration, including satellite deployment, deep-space missions, and potential interstellar travel. 2. Theoretical Foundation 2.1 The First Cosmic Velocity (Orbital Velocity) The first cosmic velocity ( \\(v_1\\) ) is the speed required to maintain a stable circular orbit around a planet without falling back to its surface. This is also known as the orbital velocity and is derived by equating the gravitational force to the required centripetal force for circular motion. The gravitational force acting on an object of mass \\(m\\) orbiting a planet of mass \\(M\\) at radius \\(r\\) is: \\[F_g = \\frac{G M m}{r^2}\\] The required centripetal force to maintain circular motion is: \\[F_c = \\frac{m v_1^2}{r}\\] Setting these equal to each other: \\[\\frac{G M m}{r^2} = \\frac{m v_1^2}{r}\\] Canceling \\(m\\) and solving for \\(v_1\\) : \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] This is the velocity needed for a circular orbit at radius \\(r\\) . If an object moves slower than this, it will fall back to the planet; if it moves faster, it will enter an elliptical or escape trajectory. 2.2 The Second Cosmic Velocity (Escape Velocity) The second cosmic velocity ( \\(v_2\\) ) is the escape velocity , which is the minimum speed an object must reach to break free from a planet\u2019s gravitational field without additional propulsion. We derive this by considering energy conservation . A body is considered to have escaped if its total mechanical energy is non-negative: \\[E = K + U \\geq 0\\] where: - \\(K = \\frac{1}{2} m v^2\\) is the kinetic energy , - \\(U = -\\frac{G M m}{r}\\) is the gravitational potential energy . At the planet\u2019s surface ( \\(r = R\\) ), the object must have enough kinetic energy to reach \\(r \\to \\infty\\) , where \\(U \\to 0\\) . Thus, we set: \\[\\frac{1}{2} m v_2^2 - \\frac{G M m}{R} = 0\\] Solving for \\(v_2\\) : \\[v_2 = \\sqrt{\\frac{2 G M}{R}}\\] This means that to completely escape the gravitational pull of a planet, an object must travel at least \\(v_2\\) . If launched with a velocity lower than \\(v_2\\) , it will eventually fall back or enter an elliptical orbit. 2.3 The Third Cosmic Velocity (Interplanetary Velocity) The third cosmic velocity ( \\(v_3\\) ) is the velocity required for an object to escape from a star\u2019s gravitational field while starting from a planet\u2019s orbit. This applies to interstellar missions, where spacecraft need to leave the Solar System entirely. We can derive \\(v_3\\) similarly to \\(v_2\\) , but now considering escape from the Sun\u2019s gravitational field rather than a planet\u2019s. If an object starts from a planet at distance \\(R_p\\) from the Sun (e.g., Earth\u2019s orbital radius \\(R_E\\) ), the escape velocity from the Sun is: \\[v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2}\\] where: - \\(v_2 = \\sqrt{\\frac{2 G M_{\\odot}}{R_p}}\\) is the escape velocity from the Sun at distance \\(R_p\\) , - \\(v_{\\text{orb}} = \\sqrt{\\frac{G M_{\\odot}}{R_p}}\\) is the orbital velocity of the planet around the Sun. Simplifying: \\[v_3 = \\sqrt{3 \\frac{G M_{\\odot}}{R_p}}\\] This shows that interstellar probes must exceed three times the Sun\u2019s orbital velocity at that location to escape its gravity completely. 3. Computational Analysis To visualize these velocities, we compute and compare them for Earth, Mars, and Jupiter . 3.1 Python Simulation of Escape and Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": {\"M\": 5.97e24, \"R\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"R\": 3.389e6}, \"Jupiter\": {\"M\": 1.90e27, \"R\": 6.9911e7} } # Calculate velocities for planet, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity print(f\"{planet}:\") print(f\" First Cosmic Velocity (Orbital) = {v1:.2f} m/s\") print(f\" Second Cosmic Velocity (Escape) = {v2:.2f} m/s\\n\") # Plot escape velocity vs. planetary radius radii = np.array([data[\"R\"] for data in bodies.values()]) velocities = np.array([np.sqrt(2 * G * data[\"M\"] / data[\"R\"]) for data in bodies.values()]) plt.figure(figsize=(8, 6)) plt.scatter(radii / 1e6, velocities / 1e3, color='r', label='Escape Velocity') plt.xlabel(\"Planetary Radius (x10^6 m)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.title(\"Escape Velocities for Different Planets\") plt.legend() plt.grid() plt.show() Colab 3.2 Interpretation of Results Earth: Orbital velocity: ~7.91 km/s Escape velocity: ~11.19 km/s Mars: Orbital velocity: ~3.58 km/s Escape velocity: ~5.02 km/s Jupiter: Orbital velocity: ~42.1 km/s Escape velocity: ~59.5 km/s Since Jupiter has a much larger mass than Earth or Mars, its escape velocity is significantly higher, requiring much more energy for missions to leave its gravitational influence. 4. Conclusion Escape and cosmic velocities are crucial concepts in space travel. The relationships derived help determine the speeds needed to reach orbit, escape planets, and even leave the Solar System. Understanding these velocities allows scientists and engineers to design efficient space missions, optimize fuel consumption, and explore beyond Earth.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"The ability of an object to leave the gravitational influence of a celestial body is a fundamental concept in space exploration. Understanding how fast a spacecraft or any object must travel to achieve a stable orbit, escape a planet, or even leave a star system entirely is crucial for designing space missions, launching satellites, and interplanetary travel. The escape velocity is the minimum speed an object must have to completely overcome a planet\u2019s gravitational pull without further propulsion. More generally, the cosmic velocities define different velocity thresholds required for various stages of motion in space: 1. The first cosmic velocity (orbital velocity) allows an object to maintain a stable circular orbit around a planet. 2. The second cosmic velocity (escape velocity) is the minimum velocity needed to leave the planet\u2019s gravitational influence. 3. The third cosmic velocity (interplanetary velocity) is the speed required to escape a star\u2019s gravitational field from a planet\u2019s orbit. This report aims to: 1. Define and derive the equations for the first, second, and third cosmic velocities. 2. Analyze the factors affecting these velocities, such as planetary mass and radius. 3. Compute and visualize these velocities for different celestial bodies, including Earth, Mars, and Jupiter. 4. Explore their significance in space exploration, including satellite deployment, deep-space missions, and potential interstellar travel.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-the-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity ( \\(v_1\\) ) is the speed required to maintain a stable circular orbit around a planet without falling back to its surface. This is also known as the orbital velocity and is derived by equating the gravitational force to the required centripetal force for circular motion. The gravitational force acting on an object of mass \\(m\\) orbiting a planet of mass \\(M\\) at radius \\(r\\) is: \\[F_g = \\frac{G M m}{r^2}\\] The required centripetal force to maintain circular motion is: \\[F_c = \\frac{m v_1^2}{r}\\] Setting these equal to each other: \\[\\frac{G M m}{r^2} = \\frac{m v_1^2}{r}\\] Canceling \\(m\\) and solving for \\(v_1\\) : \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] This is the velocity needed for a circular orbit at radius \\(r\\) . If an object moves slower than this, it will fall back to the planet; if it moves faster, it will enter an elliptical or escape trajectory.","title":"2.1 The First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-the-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity ( \\(v_2\\) ) is the escape velocity , which is the minimum speed an object must reach to break free from a planet\u2019s gravitational field without additional propulsion. We derive this by considering energy conservation . A body is considered to have escaped if its total mechanical energy is non-negative: \\[E = K + U \\geq 0\\] where: - \\(K = \\frac{1}{2} m v^2\\) is the kinetic energy , - \\(U = -\\frac{G M m}{r}\\) is the gravitational potential energy . At the planet\u2019s surface ( \\(r = R\\) ), the object must have enough kinetic energy to reach \\(r \\to \\infty\\) , where \\(U \\to 0\\) . Thus, we set: \\[\\frac{1}{2} m v_2^2 - \\frac{G M m}{R} = 0\\] Solving for \\(v_2\\) : \\[v_2 = \\sqrt{\\frac{2 G M}{R}}\\] This means that to completely escape the gravitational pull of a planet, an object must travel at least \\(v_2\\) . If launched with a velocity lower than \\(v_2\\) , it will eventually fall back or enter an elliptical orbit.","title":"2.2 The Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-the-third-cosmic-velocity-interplanetary-velocity","text":"The third cosmic velocity ( \\(v_3\\) ) is the velocity required for an object to escape from a star\u2019s gravitational field while starting from a planet\u2019s orbit. This applies to interstellar missions, where spacecraft need to leave the Solar System entirely. We can derive \\(v_3\\) similarly to \\(v_2\\) , but now considering escape from the Sun\u2019s gravitational field rather than a planet\u2019s. If an object starts from a planet at distance \\(R_p\\) from the Sun (e.g., Earth\u2019s orbital radius \\(R_E\\) ), the escape velocity from the Sun is: \\[v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2}\\] where: - \\(v_2 = \\sqrt{\\frac{2 G M_{\\odot}}{R_p}}\\) is the escape velocity from the Sun at distance \\(R_p\\) , - \\(v_{\\text{orb}} = \\sqrt{\\frac{G M_{\\odot}}{R_p}}\\) is the orbital velocity of the planet around the Sun. Simplifying: \\[v_3 = \\sqrt{3 \\frac{G M_{\\odot}}{R_p}}\\] This shows that interstellar probes must exceed three times the Sun\u2019s orbital velocity at that location to escape its gravity completely.","title":"2.3 The Third Cosmic Velocity (Interplanetary Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-computational-analysis","text":"To visualize these velocities, we compute and compare them for Earth, Mars, and Jupiter .","title":"3. Computational Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-python-simulation-of-escape-and-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": {\"M\": 5.97e24, \"R\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"R\": 3.389e6}, \"Jupiter\": {\"M\": 1.90e27, \"R\": 6.9911e7} } # Calculate velocities for planet, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity print(f\"{planet}:\") print(f\" First Cosmic Velocity (Orbital) = {v1:.2f} m/s\") print(f\" Second Cosmic Velocity (Escape) = {v2:.2f} m/s\\n\") # Plot escape velocity vs. planetary radius radii = np.array([data[\"R\"] for data in bodies.values()]) velocities = np.array([np.sqrt(2 * G * data[\"M\"] / data[\"R\"]) for data in bodies.values()]) plt.figure(figsize=(8, 6)) plt.scatter(radii / 1e6, velocities / 1e3, color='r', label='Escape Velocity') plt.xlabel(\"Planetary Radius (x10^6 m)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.title(\"Escape Velocities for Different Planets\") plt.legend() plt.grid() plt.show() Colab","title":"3.1 Python Simulation of Escape and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-interpretation-of-results","text":"Earth: Orbital velocity: ~7.91 km/s Escape velocity: ~11.19 km/s Mars: Orbital velocity: ~3.58 km/s Escape velocity: ~5.02 km/s Jupiter: Orbital velocity: ~42.1 km/s Escape velocity: ~59.5 km/s Since Jupiter has a much larger mass than Earth or Mars, its escape velocity is significantly higher, requiring much more energy for missions to leave its gravitational influence.","title":"3.2 Interpretation of Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-conclusion","text":"Escape and cosmic velocities are crucial concepts in space travel. The relationships derived help determine the speeds needed to reach orbit, escape planets, and even leave the Solar System. Understanding these velocities allows scientists and engineers to design efficient space missions, optimize fuel consumption, and explore beyond Earth.","title":"4. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Escape Velocities and Cosmic Velocities Motivation: The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task Breakdown 1. Defining the First, Second, and Third Cosmic Velocities Escape Velocity (Second Cosmic Velocity) Escape velocity is the minimum velocity an object must have to escape the gravitational pull of a celestial body without further propulsion. It is defined as the velocity at which the kinetic energy of the object equals the gravitational potential energy . Mathematically, escape velocity \\(v_e\\) is given by: \\([ v_e = \\sqrt{\\frac{2GM}{R}} ]\\) Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is the distance from the center of the celestial body to the object. Escape velocity is critical for space exploration because it determines the energy required to launch a spacecraft or satellite into space. First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the velocity an object must have to enter into a stable orbit around a celestial body. This is the velocity at which the centripetal force required to maintain an orbit equals the gravitational force acting on the object. The orbital velocity \\(v_o\\) is given by: \\([ v_o = \\sqrt{\\frac{GM}{R}} ]\\) Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is the distance from the center of the celestial body to the orbiting object. The first cosmic velocity is vital for placing satellites into orbit, as it ensures the object moves fast enough to balance gravitational forces. Third Cosmic Velocity (Escape from the Solar System) The third cosmic velocity is the velocity an object needs to escape the gravitational influence of the Sun (or any star) and move away from the star system indefinitely. This velocity is calculated using the gravitational force of the Sun and takes into account the distance from the object to the Sun. The third cosmic velocity \\(v_3\\) is given by: \\([ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{R_{\\text{sun}}} + \\frac{v_{\\text{escape}}^2}{2}} ]\\) Where: - \\(M_{\\text{sun}}\\) is the mass of the Sun, - \\(R_{\\text{sun}}\\) is the distance from the Sun to the object, - \\(v_{\\text{escape}}\\) is the escape velocity at the Earth's surface or any other celestial body in question. This velocity is essential for interstellar travel or missions that aim to leave the solar system. 2. Mathematical Derivations and Parameters Affecting These Velocities The escape velocities and cosmic velocities depend on the mass \\(M\\) of the celestial body and the distance \\(R\\) from the center of mass to the object. Higher mass and smaller radii lead to higher velocities, meaning it requires more energy to escape from more massive bodies or closer objects. The gravitational constant \\(G\\) remains a constant across calculations, but the mass of the object and the distances to the object play critical roles in calculating these velocities. Therefore, for different planets or celestial bodies, the velocities vary significantly. 3. Calculating and Visualizing These Velocities for Different Celestial Bodies We can calculate the first, second, and third cosmic velocities for various celestial bodies, such as Earth , Mars , and Jupiter , using the formulas above. Python Code for Cosmic Velocities Below is the Python code to calculate and visualize the escape velocities and cosmic velocities for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Masses and radii of celestial bodies (in SI units) celestial_bodies = { 'Earth': {'M': 5.972e24, 'R': 6.371e6}, 'Mars': {'M': 6.4171e23, 'R': 3.3962e6}, 'Jupiter': {'M': 1.8982e27, 'R': 6.991e7}, } # Function to calculate the first and second cosmic velocities def cosmic_velocities(M, R): v1 = np.sqrt(G * M / R) # First cosmic velocity (orbital velocity) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape velocity) return v1, v2 # Calculate velocities for each celestial body velocities = {} for body, values in celestial_bodies.items(): v1, v2 = cosmic_velocities(values['M'], values['R']) velocities[body] = {'v1': v1, 'v2': v2} # Plotting the velocities labels = list(celestial_bodies.keys()) v1_values = [velocities[body]['v1'] for body in labels] v2_values = [velocities[body]['v2'] for body in labels] x = np.arange(len(labels)) fig, ax = plt.subplots(figsize=(10, 6)) bar_width = 0.35 ax.bar(x - bar_width/2, v1_values, bar_width, label='First Cosmic Velocity (Orbital)', color='b') ax.bar(x + bar_width/2, v2_values, bar_width, label='Second Cosmic Velocity (Escape)', color='r') ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('First and Second Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() Colab 4. Importance in Space Exploration Launching Satellites and Spacecrafts Understanding escape and orbital velocities is critical for launching satellites. The first cosmic velocity ensures that satellites remain in stable orbits around Earth, allowing them to maintain a consistent path without falling back to the planet's surface. The second cosmic velocity is necessary for launching spacecraft that need to escape Earth's gravitational influence and travel into space. For instance, when sending satellites to low Earth orbit (LEO), they must reach the first cosmic velocity, which ensures they remain in orbit. For missions that aim to go beyond Earth's orbit, such as interplanetary missions to Mars or beyond, the second cosmic velocity is required to escape Earth's gravity. Missions to Other Planets For interplanetary missions, spacecraft must reach escape velocity to leave Earth's gravity well and then navigate towards other planets. After escaping Earth's gravitational field, spacecraft will use the gravitational forces of other planets to adjust their trajectory or speed (via gravity assists). For example, the Mars Rover missions require spacecraft to escape Earth's gravity (second cosmic velocity) to head towards Mars. Similarly, for probes like Voyager, the third cosmic velocity is needed to leave the solar system entirely. Interstellar Travel The third cosmic velocity represents the velocity required for interstellar travel, allowing spacecraft to break free from the Sun's gravity and travel to other star systems. While current technology does not allow us to achieve this velocity, understanding it is fundamental for future space exploration. This velocity, calculated for a spacecraft at the Earth's surface, is approximately 16.7 km/s, significantly higher than the velocities needed for orbital or escape purposes. While still beyond current technology, efforts like breakthrough propulsion (e.g., light sails or ion drives) are being researched to achieve the high speeds required for interstellar missions. 5. Graphical Representations The following bar graph visualizes the first and second cosmic velocities for Earth , Mars , and Jupiter . This representation allows us to understand how these velocities vary across different celestial bodies: Jupiter has the highest escape and orbital velocities due to its larger mass and size compared to Earth and Mars. Mars has the lowest velocities because of its smaller mass and radius in comparison to Earth and Jupiter. Earth provides an intermediate set of velocities, making it the baseline for most space missions. Graph Interpretation From the graph, we observe the following trends: - The escape velocity (second cosmic velocity) is always greater than the orbital velocity (first cosmic velocity) for all bodies. - Larger planets like Jupiter require higher velocities to escape their gravitational fields compared to smaller planets like Mars. Conclusion The concept of escape velocity and the first, second, and third cosmic velocities is essential for understanding the physics of space exploration. By calculating and visualizing these velocities, we gain insights into the challenges of launching spacecraft, sending probes to distant planets, and contemplating future interstellar travel. These velocities determine the energy required to launch missions into orbit, escape planetary gravity, and venture beyond our Solar System. Summary: Task 1: Define and explain the first, second, and third cosmic velocities, with their respective mathematical formulations. Task 2: Discuss the factors that affect these velocities, such as mass and radius of celestial bodies. Task 3: Provide Python code to calculate and visualize the first and second cosmic velocities for Earth, Mars, and Jupiter. Task 4: Explain the importance of these velocities in space exploration, particularly for satellite launches, planetary missions, and interstellar travel.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-breakdown","text":"","title":"Task Breakdown"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-defining-the-first-second-and-third-cosmic-velocities","text":"","title":"1. Defining the First, Second, and Third Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity-second-cosmic-velocity","text":"Escape velocity is the minimum velocity an object must have to escape the gravitational pull of a celestial body without further propulsion. It is defined as the velocity at which the kinetic energy of the object equals the gravitational potential energy . Mathematically, escape velocity \\(v_e\\) is given by: \\([ v_e = \\sqrt{\\frac{2GM}{R}} ]\\) Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is the distance from the center of the celestial body to the object. Escape velocity is critical for space exploration because it determines the energy required to launch a spacecraft or satellite into space.","title":"Escape Velocity (Second Cosmic Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the velocity an object must have to enter into a stable orbit around a celestial body. This is the velocity at which the centripetal force required to maintain an orbit equals the gravitational force acting on the object. The orbital velocity \\(v_o\\) is given by: \\([ v_o = \\sqrt{\\frac{GM}{R}} ]\\) Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is the distance from the center of the celestial body to the orbiting object. The first cosmic velocity is vital for placing satellites into orbit, as it ensures the object moves fast enough to balance gravitational forces.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#third-cosmic-velocity-escape-from-the-solar-system","text":"The third cosmic velocity is the velocity an object needs to escape the gravitational influence of the Sun (or any star) and move away from the star system indefinitely. This velocity is calculated using the gravitational force of the Sun and takes into account the distance from the object to the Sun. The third cosmic velocity \\(v_3\\) is given by: \\([ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{R_{\\text{sun}}} + \\frac{v_{\\text{escape}}^2}{2}} ]\\) Where: - \\(M_{\\text{sun}}\\) is the mass of the Sun, - \\(R_{\\text{sun}}\\) is the distance from the Sun to the object, - \\(v_{\\text{escape}}\\) is the escape velocity at the Earth's surface or any other celestial body in question. This velocity is essential for interstellar travel or missions that aim to leave the solar system.","title":"Third Cosmic Velocity (Escape from the Solar System)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-derivations-and-parameters-affecting-these-velocities","text":"The escape velocities and cosmic velocities depend on the mass \\(M\\) of the celestial body and the distance \\(R\\) from the center of mass to the object. Higher mass and smaller radii lead to higher velocities, meaning it requires more energy to escape from more massive bodies or closer objects. The gravitational constant \\(G\\) remains a constant across calculations, but the mass of the object and the distances to the object play critical roles in calculating these velocities. Therefore, for different planets or celestial bodies, the velocities vary significantly.","title":"2. Mathematical Derivations and Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-calculating-and-visualizing-these-velocities-for-different-celestial-bodies","text":"We can calculate the first, second, and third cosmic velocities for various celestial bodies, such as Earth , Mars , and Jupiter , using the formulas above.","title":"3. Calculating and Visualizing These Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-cosmic-velocities","text":"Below is the Python code to calculate and visualize the escape velocities and cosmic velocities for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Masses and radii of celestial bodies (in SI units) celestial_bodies = { 'Earth': {'M': 5.972e24, 'R': 6.371e6}, 'Mars': {'M': 6.4171e23, 'R': 3.3962e6}, 'Jupiter': {'M': 1.8982e27, 'R': 6.991e7}, } # Function to calculate the first and second cosmic velocities def cosmic_velocities(M, R): v1 = np.sqrt(G * M / R) # First cosmic velocity (orbital velocity) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape velocity) return v1, v2 # Calculate velocities for each celestial body velocities = {} for body, values in celestial_bodies.items(): v1, v2 = cosmic_velocities(values['M'], values['R']) velocities[body] = {'v1': v1, 'v2': v2} # Plotting the velocities labels = list(celestial_bodies.keys()) v1_values = [velocities[body]['v1'] for body in labels] v2_values = [velocities[body]['v2'] for body in labels] x = np.arange(len(labels)) fig, ax = plt.subplots(figsize=(10, 6)) bar_width = 0.35 ax.bar(x - bar_width/2, v1_values, bar_width, label='First Cosmic Velocity (Orbital)', color='b') ax.bar(x + bar_width/2, v2_values, bar_width, label='Second Cosmic Velocity (Escape)', color='r') ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('First and Second Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() Colab","title":"Python Code for Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-importance-in-space-exploration","text":"","title":"4. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#launching-satellites-and-spacecrafts","text":"Understanding escape and orbital velocities is critical for launching satellites. The first cosmic velocity ensures that satellites remain in stable orbits around Earth, allowing them to maintain a consistent path without falling back to the planet's surface. The second cosmic velocity is necessary for launching spacecraft that need to escape Earth's gravitational influence and travel into space. For instance, when sending satellites to low Earth orbit (LEO), they must reach the first cosmic velocity, which ensures they remain in orbit. For missions that aim to go beyond Earth's orbit, such as interplanetary missions to Mars or beyond, the second cosmic velocity is required to escape Earth's gravity.","title":"Launching Satellites and Spacecrafts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#missions-to-other-planets","text":"For interplanetary missions, spacecraft must reach escape velocity to leave Earth's gravity well and then navigate towards other planets. After escaping Earth's gravitational field, spacecraft will use the gravitational forces of other planets to adjust their trajectory or speed (via gravity assists). For example, the Mars Rover missions require spacecraft to escape Earth's gravity (second cosmic velocity) to head towards Mars. Similarly, for probes like Voyager, the third cosmic velocity is needed to leave the solar system entirely.","title":"Missions to Other Planets"},{"location":"1%20Physics/2%20Gravity/Problem_3/#interstellar-travel","text":"The third cosmic velocity represents the velocity required for interstellar travel, allowing spacecraft to break free from the Sun's gravity and travel to other star systems. While current technology does not allow us to achieve this velocity, understanding it is fundamental for future space exploration. This velocity, calculated for a spacecraft at the Earth's surface, is approximately 16.7 km/s, significantly higher than the velocities needed for orbital or escape purposes. While still beyond current technology, efforts like breakthrough propulsion (e.g., light sails or ion drives) are being researched to achieve the high speeds required for interstellar missions.","title":"Interstellar Travel"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-graphical-representations","text":"The following bar graph visualizes the first and second cosmic velocities for Earth , Mars , and Jupiter . This representation allows us to understand how these velocities vary across different celestial bodies: Jupiter has the highest escape and orbital velocities due to its larger mass and size compared to Earth and Mars. Mars has the lowest velocities because of its smaller mass and radius in comparison to Earth and Jupiter. Earth provides an intermediate set of velocities, making it the baseline for most space missions.","title":"5. Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graph-interpretation","text":"From the graph, we observe the following trends: - The escape velocity (second cosmic velocity) is always greater than the orbital velocity (first cosmic velocity) for all bodies. - Larger planets like Jupiter require higher velocities to escape their gravitational fields compared to smaller planets like Mars.","title":"Graph Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"The concept of escape velocity and the first, second, and third cosmic velocities is essential for understanding the physics of space exploration. By calculating and visualizing these velocities, we gain insights into the challenges of launching spacecraft, sending probes to distant planets, and contemplating future interstellar travel. These velocities determine the energy required to launch missions into orbit, escape planetary gravity, and venture beyond our Solar System.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Task 1: Define and explain the first, second, and third cosmic velocities, with their respective mathematical formulations. Task 2: Discuss the factors that affect these velocities, such as mass and radius of celestial bodies. Task 3: Provide Python code to calculate and visualize the first and second cosmic velocities for Earth, Mars, and Jupiter. Task 4: Explain the importance of these velocities in space exploration, particularly for satellite launches, planetary missions, and interstellar travel.","title":"Summary:"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Introduction Wave interference occurs when multiple waves overlap, leading to constructive (amplification) and destructive (cancellation) interference. On a water surface , circular waves from different sources create complex interference patterns , which are influenced by the number, position, and phase of sources . This study investigates interference patterns from multiple point sources arranged in regular polygons . Understanding such patterns has applications in acoustics, optics, and fluid dynamics . 2. Theoretical Background 2.1 Wave Equation for a Point Source A circular wave from a point source at position \\(\\mathbf{r_i}\\) is given by: \\[\\psi_i(\\mathbf{r}, t) = A \\cos(k r_i - \\omega t + \\phi_0)\\] where: - \\(\\psi_i(\\mathbf{r}, t)\\) is the displacement at point \\(\\mathbf{r}\\) and time \\(t\\) . - \\(A\\) is the amplitude . - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number . - \\(\\omega = 2\\pi f\\) is the angular frequency . - \\(r_i = |\\mathbf{r} - \\mathbf{r_i}|\\) is the distance from the source. - \\(\\phi_0\\) is the initial phase . 2.2 Superposition of Multiple Waves If there are \\(N\\) wave sources at positions \\(\\mathbf{r_i}\\) , the total displacement is: \\[\\Psi(\\mathbf{r}, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi_0)\\] The interference pattern results from this sum. 2.3 Regular Polygon Source Arrangement We place sources at the vertices of a regular polygon (e.g., triangle, square, pentagon ) with center at the origin. Each vertex has coordinates: \\[\\mathbf{r_i} = R (\\cos \\theta_i, \\sin \\theta_i)\\] where \\(\\theta_i = \\frac{2\\pi i}{N}\\) , for \\(i = 0, 1, ..., N-1\\) . 3. Computational Simulation Python Implementation We simulate wave interference for sources placed at the vertices of a regular polygon using NumPy and Matplotlib . import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_wave = 1 # Wavelength k = 2 * np.pi / lambda_wave # Wave number omega = 2 * np.pi # Angular frequency N = 5 # Number of sources (Regular pentagon) R = 5 # Distance of sources from origin grid_size = 200 # Resolution # Define spatial grid x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) # Define source positions (vertices of polygon) angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(angle), R * np.sin(angle)) for angle in angles] # Compute wave superposition wave_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) wave_sum += A * np.cos(k * r) # Plot the interference pattern plt.figure(figsize=(7, 7)) plt.imshow(wave_sum, extent=[-10, 10, -10, 10], cmap=\"RdBu\", origin=\"lower\") plt.colorbar(label=\"Wave Displacement\") plt.scatter(*zip(*sources), color=\"black\", marker=\"o\", label=\"Wave Sources\") plt.title(\"Interference Pattern for a Regular Pentagon\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.show() Colab 4. Results and Discussion Constructive Interference occurs where waves reinforce each other, creating bright regions. Destructive Interference occurs where waves cancel, forming dark regions. The polygon shape affects the pattern , leading to symmetric and repeating interference zones . Different Polygon Cases Polygon Interference Behavior Triangle (N=3) Large interference zones, simple symmetry. Square (N=4) More complex interference fringes. Pentagon (N=5) Higher symmetry, intricate wave interactions. Real-World Applications Optics: Interference of light waves in holography and diffraction gratings . Acoustics: Sound wave interference in concert halls and speaker systems . Fluid Dynamics: Wave interactions in oceans and engineering . 5. Conclusion This report investigated wave interference on a water surface for multiple sources arranged in regular polygons . The numerical simulation confirmed that the source arrangement significantly influences interference patterns . Future work could explore nonlinear effects, wave damping, and 3D wave interactions .","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-introduction","text":"Wave interference occurs when multiple waves overlap, leading to constructive (amplification) and destructive (cancellation) interference. On a water surface , circular waves from different sources create complex interference patterns , which are influenced by the number, position, and phase of sources . This study investigates interference patterns from multiple point sources arranged in regular polygons . Understanding such patterns has applications in acoustics, optics, and fluid dynamics .","title":"1. Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-wave-equation-for-a-point-source","text":"A circular wave from a point source at position \\(\\mathbf{r_i}\\) is given by: \\[\\psi_i(\\mathbf{r}, t) = A \\cos(k r_i - \\omega t + \\phi_0)\\] where: - \\(\\psi_i(\\mathbf{r}, t)\\) is the displacement at point \\(\\mathbf{r}\\) and time \\(t\\) . - \\(A\\) is the amplitude . - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number . - \\(\\omega = 2\\pi f\\) is the angular frequency . - \\(r_i = |\\mathbf{r} - \\mathbf{r_i}|\\) is the distance from the source. - \\(\\phi_0\\) is the initial phase .","title":"2.1 Wave Equation for a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-superposition-of-multiple-waves","text":"If there are \\(N\\) wave sources at positions \\(\\mathbf{r_i}\\) , the total displacement is: \\[\\Psi(\\mathbf{r}, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi_0)\\] The interference pattern results from this sum.","title":"2.2 Superposition of Multiple Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#23-regular-polygon-source-arrangement","text":"We place sources at the vertices of a regular polygon (e.g., triangle, square, pentagon ) with center at the origin. Each vertex has coordinates: \\[\\mathbf{r_i} = R (\\cos \\theta_i, \\sin \\theta_i)\\] where \\(\\theta_i = \\frac{2\\pi i}{N}\\) , for \\(i = 0, 1, ..., N-1\\) .","title":"2.3 Regular Polygon Source Arrangement"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-computational-simulation","text":"","title":"3. Computational Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation","text":"We simulate wave interference for sources placed at the vertices of a regular polygon using NumPy and Matplotlib . import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_wave = 1 # Wavelength k = 2 * np.pi / lambda_wave # Wave number omega = 2 * np.pi # Angular frequency N = 5 # Number of sources (Regular pentagon) R = 5 # Distance of sources from origin grid_size = 200 # Resolution # Define spatial grid x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) # Define source positions (vertices of polygon) angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(angle), R * np.sin(angle)) for angle in angles] # Compute wave superposition wave_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) wave_sum += A * np.cos(k * r) # Plot the interference pattern plt.figure(figsize=(7, 7)) plt.imshow(wave_sum, extent=[-10, 10, -10, 10], cmap=\"RdBu\", origin=\"lower\") plt.colorbar(label=\"Wave Displacement\") plt.scatter(*zip(*sources), color=\"black\", marker=\"o\", label=\"Wave Sources\") plt.title(\"Interference Pattern for a Regular Pentagon\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.show() Colab","title":"Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-results-and-discussion","text":"Constructive Interference occurs where waves reinforce each other, creating bright regions. Destructive Interference occurs where waves cancel, forming dark regions. The polygon shape affects the pattern , leading to symmetric and repeating interference zones .","title":"4. Results and Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#different-polygon-cases","text":"Polygon Interference Behavior Triangle (N=3) Large interference zones, simple symmetry. Square (N=4) More complex interference fringes. Pentagon (N=5) Higher symmetry, intricate wave interactions.","title":"Different Polygon Cases"},{"location":"1%20Physics/3%20Waves/Problem_1/#real-world-applications","text":"Optics: Interference of light waves in holography and diffraction gratings . Acoustics: Sound wave interference in concert halls and speaker systems . Fluid Dynamics: Wave interactions in oceans and engineering .","title":"Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"This report investigated wave interference on a water surface for multiple sources arranged in regular polygons . The numerical simulation confirmed that the source arrangement significantly influences interference patterns . Future work could explore nonlinear effects, wave damping, and 3D wave interactions .","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}